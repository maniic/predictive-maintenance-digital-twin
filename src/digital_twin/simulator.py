"""
Degradation Simulator for Digital Twin

Simulates realistic sensor degradation patterns calibrated from actual C-MAPSS data.
"""

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Optional

import numpy as np
import pandas as pd


class FaultMode(Enum):
    """Fault modes from C-MAPSS dataset."""
    HPC_DEGRADATION = "hpc"      # High Pressure Compressor
    FAN_DEGRADATION = "fan"      # Fan degradation
    COMBINED = "combined"        # Both fault modes


@dataclass
class DegradationConfig:
    """Configuration for degradation simulation."""
    fault_mode: FaultMode = FaultMode.HPC_DEGRADATION
    degradation_rate: float = 1.0   # Multiplier (1.0 = normal, 2.0 = 2x faster)
    noise_level: float = 1.0        # Noise multiplier (1.0 = realistic)
    initial_rul: int = 150          # Starting RUL
    random_seed: Optional[int] = None


# Calibrated sensor profiles from actual C-MAPSS FD001 data analysis
# Generated by analyzing healthy (RUL > 100) vs degraded (RUL < 20) engine states
CALIBRATED_SENSOR_PROFILES = {
    # Sensors that INCREASE with degradation (higher values = more degraded)
    "sensor_2": {
        "baseline": 642.68, "std": 0.50,
        "healthy_range": (641.21, 643.80), "degraded_range": (642.22, 644.53),
        "direction": 1
    },
    "sensor_3": {
        "baseline": 1590.52, "std": 6.13,
        "healthy_range": (1571.04, 1605.29), "degraded_range": (1587.85, 1616.91),
        "direction": 1
    },
    "sensor_4": {
        "baseline": 1408.93, "std": 9.00,
        "healthy_range": (1382.25, 1423.02), "degraded_range": (1407.36, 1441.49),
        "direction": 1
    },
    "sensor_8": {
        "baseline": 2388.10, "std": 0.07,
        "healthy_range": (2387.90, 2388.24), "degraded_range": (2388.03, 2388.56),
        "direction": 1
    },
    "sensor_9": {
        "baseline": 9065.24, "std": 22.08,
        "healthy_range": (9031.97, 9088.71), "degraded_range": (9021.73, 9244.59),
        "direction": 1
    },
    "sensor_11": {
        "baseline": 47.54, "std": 0.27,
        "healthy_range": (46.85, 47.91), "degraded_range": (47.49, 48.53),
        "direction": 1
    },
    "sensor_13": {
        "baseline": 2388.10, "std": 0.07,
        "healthy_range": (2387.89, 2388.24), "degraded_range": (2388.00, 2388.56),
        "direction": 1
    },
    "sensor_14": {
        "baseline": 8143.75, "std": 19.08,
        "healthy_range": (8114.50, 8164.66), "degraded_range": (8099.94, 8293.72),
        "direction": 1
    },
    "sensor_15": {
        "baseline": 8.44, "std": 0.04,
        "healthy_range": (8.32, 8.51), "degraded_range": (8.43, 8.58),
        "direction": 1
    },
    "sensor_17": {
        "baseline": 393.21, "std": 1.55,
        "healthy_range": (388.00, 396.00), "degraded_range": (392.00, 400.00),
        "direction": 1
    },
    # Sensors that DECREASE with degradation (lower values = more degraded)
    "sensor_7": {
        "baseline": 553.37, "std": 0.89,
        "healthy_range": (551.82, 556.06), "degraded_range": (549.85, 554.07),
        "direction": -1
    },
    "sensor_12": {
        "baseline": 521.41, "std": 0.74,
        "healthy_range": (520.19, 523.38), "degraded_range": (518.69, 521.63),
        "direction": -1
    },
    "sensor_20": {
        "baseline": 38.82, "std": 0.18,
        "healthy_range": (38.42, 39.43), "degraded_range": (38.14, 38.96),
        "direction": -1
    },
    "sensor_21": {
        "baseline": 23.29, "std": 0.11,
        "healthy_range": (23.05, 23.62), "degraded_range": (22.89, 23.37),
        "direction": -1
    },
    # Near-constant sensors (minimal variation, kept for compatibility)
    "sensor_1": {"baseline": 518.67, "std": 0.0, "healthy_range": (518.67, 518.67), "degraded_range": (518.67, 518.67), "direction": 0},
    "sensor_5": {"baseline": 14.62, "std": 0.0, "healthy_range": (14.62, 14.62), "degraded_range": (14.62, 14.62), "direction": 0},
    "sensor_6": {"baseline": 21.61, "std": 0.0, "healthy_range": (21.61, 21.61), "degraded_range": (21.61, 21.61), "direction": 0},
    "sensor_10": {"baseline": 1.30, "std": 0.0, "healthy_range": (1.30, 1.30), "degraded_range": (1.30, 1.30), "direction": 0},
    "sensor_16": {"baseline": 0.03, "std": 0.0, "healthy_range": (0.03, 0.03), "degraded_range": (0.03, 0.03), "direction": 0},
    "sensor_18": {"baseline": 2388.0, "std": 0.0, "healthy_range": (2388.0, 2388.0), "degraded_range": (2388.0, 2388.0), "direction": 0},
    "sensor_19": {"baseline": 100.0, "std": 0.0, "healthy_range": (100.0, 100.0), "degraded_range": (100.0, 100.0), "direction": 0},
}

# FD001 operating conditions (single condition)
OPERATING_CONDITIONS = {
    "setting_1": {"mean": 0.0, "std": 0.002},
    "setting_2": {"mean": 0.0, "std": 0.0003},
    "setting_3": {"mean": 100.0, "std": 0.0},
}


class DegradationSimulator:
    """Simulate realistic engine sensor degradation.

    Calibrated from actual C-MAPSS FD001 data to produce sensor readings
    that are within the training distribution of the models.

    Example:
        sim = DegradationSimulator(DegradationConfig(initial_rul=150))
        for cycle in range(150):
            readings = sim.step()
            print(f"Cycle {sim.current_cycle}: sensor_3={readings['sensor_3']:.2f}")
    """

    def __init__(
        self,
        config: Optional[DegradationConfig] = None,
    ):
        """Initialize simulator.

        Args:
            config: Degradation configuration
        """
        self.config = config or DegradationConfig()
        self._rng = np.random.default_rng(self.config.random_seed)
        self._current_cycle = 0
        self._initial_rul = self.config.initial_rul

    @property
    def current_cycle(self) -> int:
        """Current operating cycle."""
        return self._current_cycle

    @property
    def effective_lifespan(self) -> float:
        """Effective total lifespan accounting for degradation rate."""
        return self._initial_rul / self.config.degradation_rate

    @property
    def true_rul(self) -> int:
        """True remaining useful life (for validation).

        Accounts for degradation rate - faster degradation means shorter life.
        """
        return max(0, int(self.effective_lifespan - self._current_cycle))

    @property
    def health_index(self) -> float:
        """Health index from 1.0 (healthy) to 0.0 (failed).

        Uses piecewise linear degradation matching C-MAPSS pattern.
        Accounts for degradation rate in the progress calculation.
        """
        effective_life = self.effective_lifespan
        if self._current_cycle >= effective_life:
            return 0.0

        progress = self._current_cycle / effective_life

        # Piecewise linear: healthy period then accelerating degradation
        # This matches the RUL capping assumption (first ~60% is "healthy")
        if progress < 0.4:
            # Healthy phase - minimal degradation
            return 1.0 - 0.1 * (progress / 0.4)
        elif progress < 0.7:
            # Early degradation phase
            return 0.9 - 0.3 * ((progress - 0.4) / 0.3)
        else:
            # Accelerating degradation phase
            return 0.6 - 0.6 * ((progress - 0.7) / 0.3) ** 1.2

    def _get_sensor_value(self, sensor_id: str, health: float) -> float:
        """Get sensor value based on health index.

        Interpolates between healthy and degraded ranges based on health.
        """
        profile = CALIBRATED_SENSOR_PROFILES[sensor_id]

        if profile["direction"] == 0:
            # Near-constant sensor
            return profile["baseline"]

        healthy_range = profile["healthy_range"]
        degraded_range = profile["degraded_range"]

        # Degradation factor (0 = healthy, 1 = fully degraded)
        # Note: degradation_rate is already accounted for in health_index
        degradation = 1.0 - health

        if profile["direction"] > 0:
            # Sensor increases with degradation
            healthy_val = healthy_range[0] + 0.3 * (healthy_range[1] - healthy_range[0])
            degraded_val = degraded_range[0] + 0.7 * (degraded_range[1] - degraded_range[0])
        else:
            # Sensor decreases with degradation
            healthy_val = healthy_range[0] + 0.7 * (healthy_range[1] - healthy_range[0])
            degraded_val = degraded_range[0] + 0.3 * (degraded_range[1] - degraded_range[0])

        # Interpolate
        value = healthy_val + degradation * (degraded_val - healthy_val)

        # Add realistic noise
        noise_std = profile["std"] * self.config.noise_level * 0.5
        if noise_std > 0:
            value += self._rng.normal(0, noise_std)

        return value

    def step(self) -> dict[str, float]:
        """Advance simulation by one cycle.

        Returns:
            Dictionary of sensor readings for this cycle
        """
        readings = {}
        health = self.health_index

        # Generate sensor readings
        for sensor_id in CALIBRATED_SENSOR_PROFILES:
            readings[sensor_id] = self._get_sensor_value(sensor_id, health)

        # Add operating conditions
        for setting, params in OPERATING_CONDITIONS.items():
            noise = self._rng.normal(0, params["std"]) if params["std"] > 0 else 0
            readings[setting] = params["mean"] + noise

        self._current_cycle += 1
        return readings

    def step_n(self, n: int) -> list[dict[str, float]]:
        """Advance simulation by n cycles.

        Args:
            n: Number of cycles to advance

        Returns:
            List of sensor readings for each cycle
        """
        return [self.step() for _ in range(n)]

    def reset(self, initial_rul: Optional[int] = None) -> None:
        """Reset simulator to initial state.

        Args:
            initial_rul: New initial RUL (uses config value if None)
        """
        self._current_cycle = 0
        if initial_rul is not None:
            self._initial_rul = initial_rul
        else:
            self._initial_rul = self.config.initial_rul

    def get_full_trajectory(self) -> list[dict[str, float]]:
        """Generate full degradation trajectory from start to failure.

        Resets simulator and runs to failure.

        Returns:
            List of sensor readings for entire trajectory
        """
        self.reset()
        trajectory = []
        while self.true_rul > 0:
            trajectory.append(self.step())
        return trajectory

    @classmethod
    def get_sensor_names(cls) -> list[str]:
        """Get list of all sensor names."""
        return list(CALIBRATED_SENSOR_PROFILES.keys())

    @classmethod
    def get_setting_names(cls) -> list[str]:
        """Get list of setting names."""
        return list(OPERATING_CONDITIONS.keys())


def calibrate_from_data(data_path: str = "data/raw", dataset: str = "FD001") -> dict:
    """Calibrate sensor profiles from actual C-MAPSS data.

    This function analyzes the data and prints calibration parameters.
    Used for development, not runtime.
    """
    from src.data.ingestion import CMAPSSDataLoader, compute_train_rul

    loader = CMAPSSDataLoader(raw_data_dir=data_path)
    data = loader.load_dataset(dataset)
    train_df = compute_train_rul(data.train)

    # Analyze sensors at different RUL thresholds
    healthy_df = train_df[train_df["RUL"] > 100]  # Healthy
    degraded_df = train_df[train_df["RUL"] < 30]  # Degraded

    profiles = {}
    sensor_cols = [c for c in train_df.columns if c.startswith("sensor_")]

    for sensor in sensor_cols:
        healthy_mean = healthy_df[sensor].mean()
        healthy_std = healthy_df[sensor].std()
        degraded_mean = degraded_df[sensor].mean()
        degraded_std = degraded_df[sensor].std()

        direction = 1 if degraded_mean > healthy_mean else -1 if degraded_mean < healthy_mean else 0

        profiles[sensor] = {
            "baseline": train_df[sensor].mean(),
            "std": train_df[sensor].std(),
            "healthy_range": (healthy_df[sensor].min(), healthy_df[sensor].max()),
            "degraded_range": (degraded_df[sensor].min(), degraded_df[sensor].max()),
            "direction": direction,
        }

        print(f'"{sensor}": {profiles[sensor]},')

    return profiles
